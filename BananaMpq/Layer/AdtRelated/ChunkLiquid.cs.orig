using System.Collections.Generic;
using System.Reflection;
using FurBot.Mpq.Visualization;

namespace FurBot.Mpq.Layer.AdtRelated
{
    public class ChunkLiquid : IHasVisualizableProperties
    {
        private static readonly bool[,] EmptyExistsTable = ArrayUtil.MakeTwoDimensionalArray(false, 8, 8);
        private static readonly bool[,] FullExistsTable = ArrayUtil.MakeTwoDimensionalArray(true, 8, 8);
        private const int TilesPerRow = 8;
        private const int VerticesPerRow = (TilesPerRow + 1);
        public float[,] HeightMap { get; private set; }
        public bool[,] ExistsTable { get; private set; }
        public int MinX { get; private set; }
        public int MinY { get; private set; }
        public int MaxX { get; private set; }
        public int MaxY { get; private set; }
        public float MinHeight { get; private set; }
        public float MaxHeight { get; private set; }
        public short Flags { get; private set; }
        public short Type { get; private set; }

        internal unsafe ChunkLiquid(byte* mh2oChunk, SMLiquidChunk* chunk)
        {
            if (AnyLiquidLayer(chunk))
            {
                var instance = GetInstance(mh2oChunk, chunk);
                Flags = instance->liquidObjectId;
                Type = instance->liquidType;
                MinX = MinY = 0;
                MaxY = MaxX = 8;
                MinHeight = instance->minWaterHeight;
                MaxHeight = instance->maxWaterHeight;
                if (instance->liquidObjectId < 42) // most probably for wmos...
                {
                    MinX = instance->xOffset;
                    MinY = instance->yOffset;
                    MaxX = instance->xOffset + instance->width;
                    MaxY = instance->yOffset + instance->height;
                }
                ParseExistsTable(mh2oChunk, instance);
                ParseHeightMap(mh2oChunk, instance);
            }
            else
            {
                ExistsTable = EmptyExistsTable;
                HeightMap = null;
            }
        }

        private unsafe void ParseHeightMap(byte* mh2oChunk, SMLiquidInstance* instance)
        {
            if (HasHeightMapData(instance) && UseExistsTable(instance->flags, instance->liquidType))
            {
                var data = (float*)(mh2oChunk + instance->data);
                HeightMap = new float[VerticesPerRow, VerticesPerRow];
                for (int y = MinY; y <= MaxY; y++)
                {
                    for (int x = MinX; x <= MaxX; x++)
                    {
                        int index = y*(MaxX - MinX + 1) + x;
                        HeightMap[y, x] = data[index];
                    }
                }
            }
            else
            {
                HeightMap = ArrayUtil.MakeTwoDimensionalArray(instance->maxWaterHeight, VerticesPerRow, VerticesPerRow);
            }
        }

        public static bool UseExistsTable(short flags, short liquidType)
        {
            return !IsOcean(flags, liquidType) && IsHeightMapDataFilling(flags);
        }

        /// <summary>
<<<<<<< Updated upstream
        /// Compensates for liquids like [46] in Stormwind, where liquidObjectId are 1709 (1710 usually)
=======
        /// Compensates for liquids like [46] in Stormwind, where flags are 1709 (1710 usually)
        /// Also uses the ExistsTable where appropriate, e.g. Booty Bay, where flags are 1727
>>>>>>> Stashed changes
        /// </summary>
        private static bool IsHeightMapDataFilling(short flags)
        {
<<<<<<< Updated upstream
            return true;
=======
            return ((flags >> 4) & 1) == ((flags >> 0) & 1);
>>>>>>> Stashed changes
        }

        private static bool IsOcean(short flags, short liquidType)
        {
<<<<<<< Updated upstream
            return instance->liquidObjectId == 42 || instance->liquidType == 2 || instance->liquidType == 14;
=======
            return flags == 42 || liquidType == 2 || liquidType == 14;
>>>>>>> Stashed changes
        }

        private static unsafe bool HasHeightMapData(SMLiquidInstance* instance)
        {
            return instance->data != 0;
        }

        private unsafe void ParseExistsTable(byte* mh2oChunk, SMLiquidInstance* instance)
        {
            if (instance->existsTable != 0 && UseExistsTable(instance->flags, instance->liquidType))
            {
                var table = mh2oChunk + instance->existsTable;
                ExistsTable = new bool[TilesPerRow, TilesPerRow];
                for (int x = MinX; x < MaxX; x++)
                {
                    for (int y = MinY; y < MaxY; y++)
                    {
                        int index = y*(MaxX - MinX) + x;
                        ExistsTable[y, x] = (table[index/8] & (1 << (index & 7))) != 0;
                    }
                }
            }
            else
            {
                ExistsTable = FullExistsTable;
            }
        }

        private static unsafe bool AnyLiquidLayer(SMLiquidChunk* chunk)
        {
            return chunk->layerCount > 0;
        }

        private static unsafe SMLiquidInstance* GetInstance(byte* mh2oChunk, SMLiquidChunk* chunk)
        {
            return (SMLiquidInstance*)(mh2oChunk + chunk->instanceOffset);
        }

        #region Implementation of IHasVisualizableProperties

        public IEnumerable<PropertyInfo> VisualizableProperties
        {
            get
            {
                var type = typeof(ChunkLiquid);
                return new[]
                {
                    type.GetProperty("MinX"), 
                    type.GetProperty("MinY"), 
                    type.GetProperty("MaxX"), 
                    type.GetProperty("MaxY"), 
                    type.GetProperty("MinHeight"), 
                    type.GetProperty("MaxHeight"), 
                    type.GetProperty("ExistsTable"), 
                    type.GetProperty("Flags"), 
                    type.GetProperty("Type"), 
                    type.GetProperty("HeightMap")
                };
            }
        }

        #endregion

    }
}